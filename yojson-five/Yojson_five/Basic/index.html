<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Basic (yojson-five.Yojson_five.Basic)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">yojson-five</a> &#x00BB; <a href="../index.html">Yojson_five</a> &#x00BB; Basic</nav><header class="odoc-preamble"><h1>Module <code><span>Yojson_five.Basic</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../../yojson/Yojson/Basic/index.html">Yojson.Basic</a> <span class="keyword">end</span></span></code></summary><h4 id="type-of-the-json-tree"><a href="#type-of-the-json-tree" class="anchor"></a>Type of the JSON tree</h4><h3 id="json-writers"><a href="#json-writers" class="anchor"></a>JSON writers</h3><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Write a compact JSON value to a string.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">buf</span> <p>allows to reuse an existing buffer created with <code>Buffer.create</code>. The buffer is cleared of all contents before starting and right before returning.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>initial length of the output buffer.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>appended to the output as a suffix, defaults to empty string.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">std</span> <p>use only standard JSON syntax, i.e. convert tuples and variants into standard JSON (if applicable), refuse to print NaN and infinities, require the root node to be either an object or an array. Default is <code>false</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Json_error</span> <p>if <code>float</code> value is not allowed in standard JSON.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span><span class="keyword">val</span> to_channel : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to a channel. Note: the <code>out_channel</code> is not flushed by this function.</p><p>See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_output"><a href="#val-to_output" class="anchor"></a><code><span><span class="keyword">val</span> to_output : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>&lt; output : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int.. &gt;</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to an OO channel.</p><p>See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span><span class="keyword">val</span> to_file : <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span>?suf:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to a file. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is a suffix appended to the output Newline by default for POSIX compliance.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span>?suf:string <span class="arrow">&#45;&gt;</span></span> <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to an existing buffer. See <code>to_string</code> for the role of the optional argument and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_string"><a href="#val-seq_to_string" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_string : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to a string.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix ouf each value written. Newline by default. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_channel"><a href="#val-seq_to_channel" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_channel : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to a channel.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix of each value written. Newline by default. See <code>to_channel</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_file"><a href="#val-seq_to_file" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_file : 
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to a file.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix of each value written. Newline by default. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_buffer"><a href="#val-seq_to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_buffer : 
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to an existing buffer.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix of each value written. Newline by default. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_t"><a href="#val-write_t" class="anchor"></a><code><span><span class="keyword">val</span> write_t : <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write the given JSON value to the given buffer. Provided as a writer function for atdgen.</p></div></div><h3 id="miscellaneous"><a href="#miscellaneous" class="anchor"></a>Miscellaneous</h3><div class="odoc-spec"><div class="spec value anchored" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">{t}1</span></span></code></div><div class="spec-doc"><p>Sort object fields (stable sort, comparing field names and treating them as byte sequences)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printer, useful for debugging</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-show"><a href="#val-show" class="anchor"></a><code><span><span class="keyword">val</span> show : <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert value to string, useful for debugging</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> is the monomorphic equality. Determines whether two JSON values are considered equal. In the case of JSON objects, the order of the keys does not matter, except for duplicate keys which will be considered equal as long as they are in the same input order.</p></div></div><h3 id="json-pretty-printing"><a href="#json-pretty-printing" class="anchor"></a>JSON pretty-printing</h3><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span><span class="keyword">val</span> pretty_print : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print into a <code>Format</code>.formatter. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Json_error</span> <p>if <code>float</code> value is not allowed in standard JSON.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3.1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_to_string"><a href="#val-pretty_to_string" class="anchor"></a><code><span><span class="keyword">val</span> pretty_to_string : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Pretty-print into a string. See <code>to_string</code> for the role of the optional <code>std</code> argument. See <code>pretty_print</code> for raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_to_channel"><a href="#val-pretty_to_channel" class="anchor"></a><code><span><span class="keyword">val</span> pretty_to_channel : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">{t}1</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print to a channel. See <code>to_string</code> for the role of the optional <code>std</code> argument. See <code>pretty_print</code> for raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prettify"><a href="#val-prettify" class="anchor"></a><code><span><span class="keyword">val</span> prettify : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Combined parser and pretty-printer. See <code>to_string</code> for the role of the optional <code>std</code> argument and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compact"><a href="#val-compact" class="anchor"></a><code><span><span class="keyword">val</span> compact : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Combined parser and printer. See <code>to_string</code> for the role of the optional <code>std</code> argument and raised exceptions.</p></div></div><h3 id="json-readers"><a href="#json-readers" class="anchor"></a>JSON readers</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-Finally"><a href="#exception-Finally" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Finally</span> <span class="keyword">of</span> exn * exn</span></code></div><div class="spec-doc"><p>Exception describing a failure in both finalizer and parsing.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lexer_state"><a href="#type-lexer_state" class="anchor"></a><code><span><span class="keyword">type</span> lexer_state</span><span> = </span><span>{</span></code><ol><li id="type-lexer_state.buf" class="def record field anchored"><a href="#type-lexer_state.buf" class="anchor"></a><code><span>buf : <span class="xref-unresolved">Stdlib</span>.Buffer.t;</span></code></li><li id="type-lexer_state.lnum" class="def record field anchored"><a href="#type-lexer_state.lnum" class="anchor"></a><code><span><span class="keyword">mutable</span> lnum : int;</span></code></li><li id="type-lexer_state.bol" class="def record field anchored"><a href="#type-lexer_state.bol" class="anchor"></a><code><span><span class="keyword">mutable</span> bol : int;</span></code></li><li id="type-lexer_state.fname" class="def record field anchored"><a href="#type-lexer_state.fname" class="anchor"></a><code><span><span class="keyword">mutable</span> fname : <span>string option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>This alias is provided for backward compatibility. New code should refer to <a href="../../../yojson/Yojson/index.html#type-lexer_state"><code>Yojson.lexer_state</code></a> directly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_lexer"><a href="#val-init_lexer" class="anchor"></a><code><span><span class="keyword">val</span> init_lexer : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-lexer_state">lexer_state</a></span></code></div><div class="spec-doc"><p>This alias is provided for backward compatibility. New code should use <a href="../../../yojson/Yojson/index.html#val-init_lexer"><code>Yojson.init_lexer</code></a> directly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_lexbuf"><a href="#val-from_lexbuf" class="anchor"></a><code><span><span class="keyword">val</span> from_lexbuf : <span><a href="#type-lexer_state">lexer_state</a> <span class="arrow">&#45;&gt;</span></span> <span>?stream:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">{t}1</span></span></code></div><div class="spec-doc"><p>Read a JSON value from a lexbuf. A valid initial <code>lexer_state</code> can be created with <code>init_lexer</code>. See <code>from_string</code> for the meaning of the optional arguments and raised exceptions.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stream</span> <p>indicates whether more data may follow. The default value is false and indicates that only JSON whitespace can be found between the end of the JSON value and the end of the input.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_from_string"><a href="#val-seq_from_string" class="anchor"></a><code><span><span class="keyword">val</span> seq_from_string : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Input a sequence of JSON values from a string. Whitespace between JSON values is fine but not required. See <code>from_string</code> for the meaning of the optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_from_channel"><a href="#val-seq_from_channel" class="anchor"></a><code><span><span class="keyword">val</span> seq_from_channel : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fin:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Input a sequence of JSON values from a channel. Whitespace between JSON values is fine but not required.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">fin</span> <p>finalization function executed once when the end of the sequence is reached either because there is no more input or because the input could not be parsed, raising an exception.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Finally</span> <p>When the parsing and the finalizer both raised, <code>Finally (exn, fin_exn)</code> is raised, <code>exn</code> being the parsing exception and <code>fin_exn</code> the finalizer one.</p><p>See <code>from_string</code> for the meaning of the other optional arguments and other raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_from_file"><a href="#val-seq_from_file" class="anchor"></a><code><span><span class="keyword">val</span> seq_from_file : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Input a sequence of JSON values from a file. Whitespace between JSON values is fine but not required.</p><p>See <code>from_string</code> for the meaning of the optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_from_lexbuf"><a href="#val-seq_from_lexbuf" class="anchor"></a><code><span><span class="keyword">val</span> seq_from_lexbuf : 
  <span><a href="#type-lexer_state">lexer_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?fin:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">{t}1</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Input a sequence of JSON values from a lexbuf. A valid initial <code>lexer_state</code> can be created with <code>init_lexer</code>. Whitespace between JSON values is fine but not required.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Finally</span> <p>When the parsing and the finalizer both raised, <code>Finally (exn, fin_exn)</code> is raised, <code>exn</code> being the parsing exception and <code>fin_exn</code> the finalizer one.</p><p>See <code>seq_from_channel</code> for the meaning of the optional <code>fin</code> argument and other raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-json_line"><a href="#type-json_line" class="anchor"></a><code><span><span class="keyword">type</span> json_line</span><span> = </span><span>[ </span></code><ol><li id="type-json_line.Json" class="def constructor anchored"><a href="#type-json_line.Json" class="anchor"></a><code><span>| </span></code><code><span>`Json <span class="keyword">of</span> <span class="xref-unresolved">{t}1</span></span></code></li><li id="type-json_line.Exn" class="def constructor anchored"><a href="#type-json_line.Exn" class="anchor"></a><code><span>| </span></code><code><span>`Exn <span class="keyword">of</span> exn</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>The type of values resulting from a parsing attempt of a JSON value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lineseq_from_channel"><a href="#val-lineseq_from_channel" class="anchor"></a><code><span><span class="keyword">val</span> lineseq_from_channel : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fin:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-json_line">json_line</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Input a sequence of JSON values, one per line, from a channel. Exceptions raised when reading malformed lines are caught and represented using <code>`Exn</code>.</p><p>See <code>seq_from_channel</code> for the meaning of the optional <code>fin</code> argument. See <code>from_string</code> for the meaning of the other optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lineseq_from_file"><a href="#val-lineseq_from_file" class="anchor"></a><code><span><span class="keyword">val</span> lineseq_from_file : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-json_line">json_line</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Input a sequence of JSON values, one per line, from a file. Exceptions raised when reading malformed lines are caught and represented using <code>`Exn</code>.</p><p>See <code>seq_from_channel</code> for the meaning of the optional <code>fin</code> argument. See <code>from_string</code> for the meaning of the other optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_t"><a href="#val-read_t" class="anchor"></a><code><span><span class="keyword">val</span> read_t : <span><a href="#type-lexer_state">lexer_state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">{t}1</span></span></code></div><div class="spec-doc"><p>Read a JSON value from the given lexer_state and lexing buffer and return it. Provided as a reader function for atdgen.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Util"><a href="#module-Util" class="anchor"></a><code><span><span class="keyword">module</span> Util</span><span> = <a href="../../../yojson/Yojson/Basic/Util/index.html">Yojson.Basic.Util</a></span></code></div><div class="spec-doc"><p>This module provides combinators for extracting fields from JSON values.</p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../../../yojson/Yojson/Basic/index.html#type-t">Yojson.Basic.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_string"><a href="#val-from_string" class="anchor"></a><code><span><span class="keyword">val</span> from_string : 
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_channel"><a href="#val-from_channel" class="anchor"></a><code><span><span class="keyword">val</span> from_channel : 
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_file"><a href="#val-from_file" class="anchor"></a><code><span><span class="keyword">val</span> from_file : 
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div></details></div></div></body></html>