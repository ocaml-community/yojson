<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Yojson (yojson.Yojson)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">yojson</a> &#x00BB; Yojson</nav><header class="odoc-preamble"><h1>Module <code><span>Yojson</span></code></h1><p>The Yojson library provides several types for representing JSON values, with different use cases.</p><ul><li>The <a href="#basic">Basic</a> JSON type,</li><li>The <a href="#safe">Safe</a> JSON type, a superset of JSON with safer support for integers,</li><li>The <a href="#raw">Raw</a> JSON type, a superset of JSON, safer but less integrated with OCaml types.</li></ul><p>Each of these different types have their own module.</p></header><nav class="odoc-toc"><ul><li><a href="#shared-types-and-functions">Shared types and functions</a><ul><li><a href="#type-of-the-json-tree">Type of the JSON tree</a></li><li><a href="#json-writers">JSON writers</a></li><li><a href="#miscellaneous">Miscellaneous</a></li><li><a href="#json-pretty-printing">JSON pretty-printing</a></li></ul></li><li><a href="#basic">Basic JSON tree type</a></li><li><a href="#safe">Multipurpose JSON tree type</a></li><li><a href="#json-tree-type-with-literal-int/float/string-leaves">JSON tree type with literal int/float/string leaves</a></li><li><a href="#raw">Supertype of all JSON tree types</a></li></ul></nav><div class="odoc-content"><h2 id="shared-types-and-functions"><a href="#shared-types-and-functions" class="anchor"></a>Shared types and functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-version"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : string</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Json_error"><a href="#exception-Json_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Json_error</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Exception used:</p><ul><li>in JSON readers, if parsing fails;</li><li>in JSON writers and pretty printing, if <code>float</code> value is not allowed in standard JSON.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-json_error"><a href="#val-json_error" class="anchor"></a><code><span><span class="keyword">val</span> json_error : <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Json_error</span> </li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lexer_state"><a href="#type-lexer_state" class="anchor"></a><code><span><span class="keyword">type</span> lexer_state</span><span> = </span><span>{</span></code><ol><li id="type-lexer_state.buf" class="def record field anchored"><a href="#type-lexer_state.buf" class="anchor"></a><code><span>buf : <span class="xref-unresolved">Stdlib</span>.Buffer.t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Buffer used to accumulate substrings</p><span class="comment-delim">*)</span></div></li><li id="type-lexer_state.lnum" class="def record field anchored"><a href="#type-lexer_state.lnum" class="anchor"></a><code><span><span class="keyword">mutable</span> lnum : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Current line number (counting from 1)</p><span class="comment-delim">*)</span></div></li><li id="type-lexer_state.bol" class="def record field anchored"><a href="#type-lexer_state.bol" class="anchor"></a><code><span><span class="keyword">mutable</span> bol : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Absolute position of the first character of the current line (counting from 0)</p><span class="comment-delim">*)</span></div></li><li id="type-lexer_state.fname" class="def record field anchored"><a href="#type-lexer_state.fname" class="anchor"></a><code><span><span class="keyword">mutable</span> fname : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Name referencing the input file in error messages</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Lexer_state"><a href="#module-Lexer_state" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lexer_state/index.html">Lexer_state</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_lexer"><a href="#val-init_lexer" class="anchor"></a><code><span><span class="keyword">val</span> init_lexer : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?fname:string <span class="arrow">&#45;&gt;</span></span>
  <span>?lnum:int <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-lexer_state">lexer_state</a></span></code></div><div class="spec-doc"><p>Create a fresh lexer_state record.</p></div></div><h5 id="type-of-the-json-tree"><a href="#type-of-the-json-tree" class="anchor"></a>Type of the JSON tree</h5><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>[ </span></code><ol><li id="type-t.Null" class="def constructor anchored"><a href="#type-t.Null" class="anchor"></a><code><span>| </span></code><code><span>`Null</span></code></li><li id="type-t.Bool" class="def constructor anchored"><a href="#type-t.Bool" class="anchor"></a><code><span>| </span></code><code><span>`Bool <span class="keyword">of</span> bool</span></code></li><li id="type-t.Int" class="def constructor anchored"><a href="#type-t.Int" class="anchor"></a><code><span>| </span></code><code><span>`Int <span class="keyword">of</span> int</span></code></li><li id="type-t.Intlit" class="def constructor anchored"><a href="#type-t.Intlit" class="anchor"></a><code><span>| </span></code><code><span>`Intlit <span class="keyword">of</span> string</span></code></li><li id="type-t.Float" class="def constructor anchored"><a href="#type-t.Float" class="anchor"></a><code><span>| </span></code><code><span>`Float <span class="keyword">of</span> float</span></code></li><li id="type-t.Floatlit" class="def constructor anchored"><a href="#type-t.Floatlit" class="anchor"></a><code><span>| </span></code><code><span>`Floatlit <span class="keyword">of</span> string</span></code></li><li id="type-t.String" class="def constructor anchored"><a href="#type-t.String" class="anchor"></a><code><span>| </span></code><code><span>`String <span class="keyword">of</span> string</span></code></li><li id="type-t.Stringlit" class="def constructor anchored"><a href="#type-t.Stringlit" class="anchor"></a><code><span>| </span></code><code><span>`Stringlit <span class="keyword">of</span> string</span></code></li><li id="type-t.Assoc" class="def constructor anchored"><a href="#type-t.Assoc" class="anchor"></a><code><span>| </span></code><code><span>`Assoc <span class="keyword">of</span> <span><span>(string * <a href="#type-t">t</a>)</span> list</span></span></code></li><li id="type-t.List" class="def constructor anchored"><a href="#type-t.List" class="anchor"></a><code><span>| </span></code><code><span>`List <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span></span></code></li><li id="type-t.Tuple" class="def constructor anchored"><a href="#type-t.Tuple" class="anchor"></a><code><span>| </span></code><code><span>`Tuple <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span></span></code></li><li id="type-t.Variant" class="def constructor anchored"><a href="#type-t.Variant" class="anchor"></a><code><span>| </span></code><code><span>`Variant <span class="keyword">of</span> string * <span><a href="#type-t">t</a> option</span></span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>All possible cases defined in Yojson:</p><ul><li>`Null: JSON null</li><li>`Bool of bool: JSON boolean</li><li>`Int of int: JSON number without decimal point or exponent.</li><li>`Intlit of string: JSON number without decimal point or exponent, preserved as a string.</li><li>`Float of float: JSON number, Infinity, -Infinity or NaN.</li><li>`Floatlit of string: JSON number, Infinity, -Infinity or NaN, preserved as a string.</li><li>`String of string: JSON string. Bytes in the range 128-255 are preserved as-is without encoding validation for both reading and writing.</li><li>`Stringlit of string: JSON string literal including the double quotes.</li><li>`Assoc of (string * json) list: JSON object.</li><li>`List of json list: JSON array.</li><li>`Tuple of json list: Tuple (non-standard extension of JSON). Syntax: <code>(&quot;abc&quot;, 123)</code>.</li><li>`Variant of (string * json option): Variant (non-standard extension of JSON). Syntax: <code>&lt;&quot;Foo&quot;&gt;</code> or <code>&lt;&quot;Bar&quot;:123&gt;</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printer, useful for debugging</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-show"><a href="#val-show" class="anchor"></a><code><span><span class="keyword">val</span> show : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert value to string, useful for debugging</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> is the monomorphic equality. Determines whether two JSON values are considered equal. In the case of JSON objects, the order of the keys does not matter, except for duplicate keys which will be considered equal as long as they are in the same input order.</p></div></div><h4 id="json-writers"><a href="#json-writers" class="anchor"></a>JSON writers</h4><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Write a compact JSON value to a string.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">buf</span> <p>allows to reuse an existing buffer created with <code>Buffer.create</code>. The buffer is cleared of all contents before starting and right before returning.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>initial length of the output buffer.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>appended to the output as a suffix, defaults to empty string.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">std</span> <p>use only standard JSON syntax, i.e. convert tuples and variants into standard JSON (if applicable), refuse to print NaN and infinities, require the root node to be either an object or an array. Default is <code>false</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Json_error</span> <p>if <code>float</code> value is not allowed in standard JSON.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span><span class="keyword">val</span> to_channel : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to a channel. Note: the <code>out_channel</code> is not flushed by this function.</p><p>See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_output"><a href="#val-to_output" class="anchor"></a><code><span><span class="keyword">val</span> to_output : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>&lt; output : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int.. &gt;</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to an OO channel.</p><p>See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span><span class="keyword">val</span> to_file : <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span>?suf:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to a file. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is a suffix appended to the output Newline by default for POSIX compliance.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span>?suf:string <span class="arrow">&#45;&gt;</span></span> <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write a compact JSON value to an existing buffer. See <code>to_string</code> for the role of the optional argument and raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_string"><a href="#val-seq_to_string" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_string : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to a string.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix ouf each value written. Newline by default. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_channel"><a href="#val-seq_to_channel" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_channel : 
  <span>?buf:<span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to a channel.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix of each value written. Newline by default. See <code>to_channel</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_file"><a href="#val-seq_to_file" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_file : 
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to a file.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix of each value written. Newline by default. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_buffer"><a href="#val-seq_to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> seq_to_buffer : 
  <span>?suf:string <span class="arrow">&#45;&gt;</span></span>
  <span>?std:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Write a sequence of <code>suf</code>-suffixed compact one-line JSON values to an existing buffer.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suf</span> <p>is the suffix of each value written. Newline by default. See <code>to_string</code> for the role of the optional arguments and raised exceptions.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_t"><a href="#val-write_t" class="anchor"></a><code><span><span class="keyword">val</span> write_t : <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write the given JSON value to the given buffer. Provided as a writer function for atdgen.</p></div></div><h4 id="miscellaneous"><a href="#miscellaneous" class="anchor"></a>Miscellaneous</h4><div class="odoc-spec"><div class="spec value anchored" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Sort object fields (stable sort, comparing field names and treating them as byte sequences)</p></div></div><h4 id="json-pretty-printing"><a href="#json-pretty-printing" class="anchor"></a>JSON pretty-printing</h4><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span><span class="keyword">val</span> pretty_print : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print into a <code>Format</code>.formatter. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Json_error</span> <p>if <code>float</code> value is not allowed in standard JSON.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3.1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_to_string"><a href="#val-pretty_to_string" class="anchor"></a><code><span><span class="keyword">val</span> pretty_to_string : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Pretty-print into a string. See <code>to_string</code> for the role of the optional <code>std</code> argument. See <code>pretty_print</code> for raised exceptions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty_to_channel"><a href="#val-pretty_to_channel" class="anchor"></a><code><span><span class="keyword">val</span> pretty_to_channel : <span>?std:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print to a channel. See <code>to_string</code> for the role of the optional <code>std</code> argument. See <code>pretty_print</code> for raised exceptions.</p></div></div><h2 id="basic"><a href="#basic" class="anchor"></a>Basic JSON tree type</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Basic"><a href="#module-Basic" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Basic/index.html">Basic</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module supports standard JSON nodes only, i.e. no special syntax for variants or tuples as supported by <a href="Safe/index.html"><code>Yojson.Safe</code></a>. Arbitrary integers are not supported as they must all fit within the standard OCaml int type (31 or 63 bits depending on the platform).</p></div></div><h2 id="safe"><a href="#safe" class="anchor"></a>Multipurpose JSON tree type</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Safe"><a href="#module-Safe" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Safe/index.html">Safe</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module supports a specific syntax for variants and tuples in addition to the standard JSON nodes. Arbitrary integers are supported and represented as a decimal string using <code>`Intlit</code> when they cannot be represented using OCaml's int type (31 or 63 bits depending on the platform).</p></div></div><h2 id="json-tree-type-with-literal-int/float/string-leaves"><a href="#json-tree-type-with-literal-int/float/string-leaves" class="anchor"></a>JSON tree type with literal int/float/string leaves</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Raw"><a href="#module-Raw" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Raw/index.html">Raw</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Ints, floats and strings literals are systematically preserved using <code>`Intlit</code>, <code>`Floatlit</code> and <code>`Stringlit</code>. This module also supports the specific syntax for variants and tuples supported by <a href="Safe/index.html"><code>Yojson.Safe</code></a>.</p></div></div><h2 id="raw"><a href="#raw" class="anchor"></a>Supertype of all JSON tree types</h2></div></body></html>